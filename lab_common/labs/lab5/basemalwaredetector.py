import logging
import os
import random
from typing import Type, Optional, List

import numpy as np
from sklearn.model_selection import train_test_split

import tensorflow as tf
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Input, Dense, Dropout
from tensorflow.keras import backend as K

from logzero import logger

from lab_common.binembeddingbuilder import BinaryEmbeddingBuilder
from lab_common.common import ROOT_PROJECT_FOLDER_PATH, RANDOM_SEED
from lab_common.embedding import BinaryEmbedding
from lab_common.labs.lab5.genmalwareembeddingdataset import GenerateMalwareEmbeddingDataset

logging.getLogger("binarycontext").setLevel(logging.WARN)
logger.setLevel(logging.INFO)

LAB_MALWARE_DATASET_DIR_PATH = os.path.join(ROOT_PROJECT_FOLDER_PATH, "lab_datasets", "lab5", "malware")
LAB_BENIGN_DATASET_DIR_PATH = os.path.join(ROOT_PROJECT_FOLDER_PATH, "lab_datasets", "lab5", "benign")

DEFAULT_DATASET_SIZE = 500


def recall_m(y_true, y_pred):
    true_positives = K.sum(K.round(K.clip(y_true * y_pred, 0, 1)))
    possible_positives = K.sum(K.round(K.clip(y_true, 0, 1)))
    recall = true_positives / (possible_positives + K.epsilon())
    return recall


def precision_m(y_true, y_pred):
    true_positives = K.sum(K.round(K.clip(y_true * y_pred, 0, 1)))
    predicted_positives = K.sum(K.round(K.clip(y_pred, 0, 1)))
    precision = true_positives / (predicted_positives + K.epsilon())
    return precision


def f1_m(y_true, y_pred):
    precision = precision_m(y_true, y_pred)
    recall = recall_m(y_true, y_pred)
    return 2 * ((precision * recall) / (precision + recall + K.epsilon()))


class BaseMalwareDetector(object):

    def __init__(self,
                 binary_embedding_builder: Type[BinaryEmbeddingBuilder],
                 clf=None,
                 malware_dataset_dir_path=LAB_MALWARE_DATASET_DIR_PATH,
                 benign_dataset_dir_path=LAB_BENIGN_DATASET_DIR_PATH,
                 dataset_size=DEFAULT_DATASET_SIZE,
                 cache_folder: Optional[str] = None,
                 ):

        self._dataset_size = dataset_size
        self._initialized = False

        self._clf = clf

        self._binary_embedding_builder: Type[BinaryEmbeddingBuilder] = binary_embedding_builder

        self._binary_embeddings: Optional[List[BinaryEmbedding]] = None

        self._cache_folder = cache_folder

        self._malware_dataset_dir_path = malware_dataset_dir_path

        self._benign_dataset_dir_path = benign_dataset_dir_path

    def initialize(self):

        if self._initialized:
            return self._initialized

        # Set the seed for Python's random library
        random.seed(RANDOM_SEED)

        # Set the seed for NumPy
        np.random.seed(RANDOM_SEED)

        # Set the seed for TensorFlow
        tf.random.set_seed(RANDOM_SEED)

        gen_malware_embedding_dataset = GenerateMalwareEmbeddingDataset(self._binary_embedding_builder,
                                                                        self._malware_dataset_dir_path,
                                                                        self._benign_dataset_dir_path,
                                                                        self._dataset_size,
                                                                        self._cache_folder)

        self._binary_embeddings = gen_malware_embedding_dataset.malware_embedding_dataset

        self._initialized = True

    def train_detector(self):

        self.initialize()

        X = np.array([embedding.embedding for embedding in self._binary_embeddings])

        y = np.array([embedding.label.value for embedding in self._binary_embeddings])

        X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.4, random_state=0)

        self._clf.fit(X_train, y_train)

        score = self._clf.score(X_test, y_test)

        logger.info(f"Score: {score}")

    def train_detector_keras(self,
                             num_layers=1,
                             epochs=1,
                             batch_size=32,
                             hidden_layer_size=32):

        self.initialize()


        embeddings = self._binary_embeddings

        X = np.array([embedding.embedding for embedding in embeddings])

        y = np.array([0 if embedding.label.value < 2 else 1 for embedding in embeddings])

        X_train, X_val, y_train, y_val = train_test_split(X, y, test_size=0.4, random_state=0)

        X_test, X_val, y_test, y_val = train_test_split(X_val, y_val, test_size=0.5, random_state=0)

        embedding_length = X.shape[1]

        # ==============Setting up the NN =========================
        model = Sequential()
        model.add(Input(shape=(embedding_length,)))
        model.add(Dropout(.2))

        for _ in range(num_layers):
            model.add(Dense(hidden_layer_size, activation='relu'))

        model.add(Dense(1, activation='sigmoid'))
        # Compile model
        model.compile(loss='binary_crossentropy', optimizer='adam',
                      metrics=[['acc', f1_m, precision_m, recall_m]])
        model.summary()

        # ============== END Setting up the NN =========================

        model.fit(x=X_train, y=y_train, batch_size=batch_size, epochs=epochs, validation_data=(X_val, y_val), verbose=2)

        logger.info("*****************Evaluating the model*****************")

        eval_results = model.evaluate(X_test, y_test,
                                      batch_size=batch_size)

        logger.info(f"{model.metrics_names}")

        logger.info(f"{eval_results}")
