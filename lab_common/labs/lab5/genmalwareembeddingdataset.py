import logging
import multiprocessing
import os
import pickle
import random
from math import ceil
from pathlib import Path
from typing import Type, Dict, List, Optional

from blackfyre.common import BINARY_CONTEXT_CONTAINER_EXT, PICKLE_EXT
from blackfyre.utils import setup_custom_logger, mkdir_p
from lab_common.binembeddingbuilder import BinaryEmbeddingBuilder

from lab_common.common import NUM_CPUS, DEFAULT_MALWARE_PERCENTAGE, RANDOM_SEED, Label
from lab_common.embedding import BinaryEmbedding


from logzero import logger

from lab_common.labs.lab5.sentencesummarizer import SentenceSummarizer

logging.getLogger("binarycontext").setLevel(logging.WARN)
logging.getLogger("pyvex.lifting.gym.arm_spotter").setLevel(logging.CRITICAL)
logging.getLogger("pyvex.lifting.gym.x86_spotter").setLevel(logging.CRITICAL)
logging.getLogger("pyvex.lifting.libvex").setLevel(logging.CRITICAL)

logger.setLevel(logging.INFO)

sentence_summarizer = None


def generate_binary_embedding(job_request):
    global sentence_summarizer
    bcc_file_path = job_request['bcc_file_path']
    binary_embedding_builder = job_request['binary_embedding_builder']
    label = job_request['label']

    if sentence_summarizer is None:
        sentence_summarizer = SentenceSummarizer()
        sentence_summarizer.initialize()
        logger.info("Initialized sentence summarizer")
    # sentence_summarizer = job_request['sentence_summarizer']

    binary_embedding = binary_embedding_builder(bcc_file_path, label, sentence_summarizer).embedding

    result = {'bcc_file_path': bcc_file_path,
              'binary_embedding': binary_embedding}

    return result


class GenerateMalwareEmbeddingDataset(object):
    def __init__(self,
                 binary_embedding_builder: Type[BinaryEmbeddingBuilder],
                 malware_dataset_dir_path,
                 benign_dataset_dir_path,
                 dataset_size: int,
                 cache_folder: str = None,
                 num_cpus: int = NUM_CPUS,
                 malware_percentage=DEFAULT_MALWARE_PERCENTAGE,
                 include_malware_bcc_files: List[str] = [],
                 max_bcc_file_size: int = 200000
                 ):
        self._binary_embedding_builder = binary_embedding_builder

        self._dataset_size = dataset_size

        self._initialized: bool = False

        self._cache_folder = cache_folder

        self._binary_embeddings: Optional[List[BinaryEmbedding]] = None

        self._num_cpus = num_cpus

        self._malware_percentage = malware_percentage

        self._malware_dataset_dir_path = malware_dataset_dir_path

        self._benign_dataset_dir_path = benign_dataset_dir_path

        self._include_malware_bcc_files = include_malware_bcc_files

        self._max_bcc_file_size = max_bcc_file_size

    def initialize(self):
        if self._initialized:
            return self._initialized

        random.seed(RANDOM_SEED)

        # Check if we should load from cache (if available)
        pickle_file_path = None
        if self._cache_folder is not None:

            pickle_file_path = os.path.join(self._cache_folder,
                                            f"malware_embedding_dataset_{int(self._malware_percentage * 100)}"
                                            f"_{self._dataset_size}."
                                            f"{PICKLE_EXT}")

            if os.path.exists(pickle_file_path):
                logger.info(f"Found cache pickled Binary Embeddings: '{pickle_file_path}'")
                self._binary_embeddings = pickle.load(open(pickle_file_path, "rb"))

        if self._binary_embeddings is None:

            self._generate_dataset()

            # cache the dataset
            if self._cache_folder:
                mkdir_p(self._cache_folder)

                pickle.dump(self._binary_embeddings, open(pickle_file_path, "wb"))
                logger.info(f"Cached Malware Embedding Dataset: '{pickle_file_path}'")

        return self._initialized

    def _generate_dataset(self):
        random.seed(RANDOM_SEED)

        self._binary_embedding_dict: Dict[str, BinaryEmbedding] = {}

        malware_bcc_file_paths = [bcc_file_path for bcc_file_path in
                                  Path(self._malware_dataset_dir_path).rglob(
                                      f"*.{BINARY_CONTEXT_CONTAINER_EXT}")
                                  if os.path.getsize(bcc_file_path) < self._max_bcc_file_size]

        benign_bcc_file_paths = [bcc_file_path for bcc_file_path in
                                 Path(self._benign_dataset_dir_path).rglob(
                                     f"*.{BINARY_CONTEXT_CONTAINER_EXT}")
                                 if os.path.getsize(bcc_file_path) < self._max_bcc_file_size]

        # Randomize the ordering and limit the number of bccs
        max_number_bcc_files = ceil(self._dataset_size)

        total_malware_bcc_files = len(malware_bcc_file_paths)

        num_request_malware_bcc_files = ceil(max_number_bcc_files * self._malware_percentage)

        num_request_malware_bcc_files -= len(self._include_malware_bcc_files)

        if num_request_malware_bcc_files > total_malware_bcc_files:
            logger.warning(f"Request for {num_request_malware_bcc_files} malware bcc files exceed actual "
                           f"number of malware bcc files  {total_malware_bcc_files}."
                           f" Will generate {total_malware_bcc_files}")
            num_request_malware_bcc_files = total_malware_bcc_files

        if num_request_malware_bcc_files > 0:
            malware_bcc_file_paths = random.sample(list(malware_bcc_file_paths), num_request_malware_bcc_files)

            malware_bcc_file_paths += self._include_malware_bcc_files

        num_request_benign_bcc_files = ceil(max_number_bcc_files * (1 - self._malware_percentage))

        total_benign_bcc_files = len(list(benign_bcc_file_paths))

        if num_request_benign_bcc_files > total_benign_bcc_files:
            logger.warning(f"Request for {num_request_benign_bcc_files} benign bcc files exceed actual "
                           f"number of benign bcc files  {total_benign_bcc_files}."
                           f" Will generate {total_benign_bcc_files}")
            num_request_benign_bcc_files = total_benign_bcc_files

        benign_bcc_file_paths = random.sample(list(benign_bcc_file_paths),num_request_benign_bcc_files)

        self._binary_embeddings = []

        with multiprocessing.Pool(processes=self._num_cpus) as pool:
            # Malware
            binary_embedding_requests = [{'bcc_file_path': bcc_file_path,
                                          'binary_embedding_builder': self._binary_embedding_builder,
                                          'label': Label.MALWARE}
                                         for bcc_file_path in malware_bcc_file_paths]
            # Benign
            binary_embedding_requests += [{'bcc_file_path': bcc_file_path,
                                           'binary_embedding_builder': self._binary_embedding_builder,
                                           'label': Label.BENIGN}
                                          for bcc_file_path in benign_bcc_file_paths]

            num_requests = len(binary_embedding_requests)
            for index, result in enumerate(
                    pool.imap_unordered(generate_binary_embedding, binary_embedding_requests)):
                bcc_file_path = result['bcc_file_path']
                binary_embedding = result['binary_embedding']
                logger.info(
                    f"[{index + 1}/{num_requests}] Created embeddings for binary context : {bcc_file_path}")

                self._binary_embeddings.append(binary_embedding)

    @property
    def malware_embedding_dataset(self):
        self.initialize()
        return self._binary_embeddings